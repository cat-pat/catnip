#!/usr/bin/env bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

# declare array -a -- -A is associative array
# dumb name for an array of images
declare -a array

# 0 is Off 1 is On
show_menu=0

# Show help menu
print_help() {
    exe="${0##*/}"
    echo -e "\e[3m\e[3m${exe} [OPTIONS] <Directory> \e[23m"
    echo -e "\e[3m\e[1m\e[4mOptions:\e[23m\e[24m "
    echo -e '    \e[3m-h, --help\e[23m'
    echo -e '    \e[3m-f, --find\e[23m'
    echo -e '    \e[3m-e, --ext\e[23m'
    echo -e '    \e[3m-s, --stdin\e[23m'
    echo -e '    \e[3m-p, --preview\e[23m'
}

cleanup() {
    # Unhide cursor
    # printf '\e[?25h'
    # re-enable line wrap | unhide cursor | clear |
    # set scroll region to default + cursor 0, 0 | restore main screen buffer
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'
    # restore echo input
    stty echo
    # restore from tput
    tput rmcup
    tput cnorm
    clear
    exit 0
}

dependency_check() {

    for x in "$@"; do
        if ! command -v "$x" &> /dev/null; then
            return 1
        else
            return 0
        fi
    done
}

save_terminal_state() {
    tput smcup
}

prepare_terminal_state() {
    get_term_size
    tput smcup && clear && stty -echo
    # printf '\e[?25l'
    printf '\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr' "$LINES"
}

unhide_cursor() {
    printf '\e[?25h'
}

hide_curs() {
    tput civis
    stty -echo
}

get_term_size() {
    read -r LINES COLUMNS < <(stty size)
}

clear_screen() {
    printf '\e[%sH\e[9999C\e[1;%sr' \
           "$((LINES-2))" "$LINES"
}

# GRADIENT + White on Background
# for the ansi option: \e[0;38;2;r;g;bm or \e[0;48;2;r;g;bm :
lightblu='\e[0;48;2;063;127;255m'
blu2='\e[0;48;2;063;063;255m'
blu3='\e[0;48;2;063;000;255m'
purple='\e[0;48;2;063;000;191m'
NC='\e[0m'

# Gradient + Foreground'
fg_blu_1='\e[0;38;2;127;191;255m' # lightest
fg_blu_2='\e[0;38;2;127;127;255m'
fg_blu_3='\e[0;38;2;127;063;255m'
fg_blu_4='\e[0;38;2;127;000;255m' # darkest

# Gradient purple in reverse
fg_purp_3='\e[0;38;2;127;000;255m' # darkest
fg_purp_2='\e[0;38;2;127;063;255m'
fg_purp_1='\e[0;38;2;127;127;255m'
fg_purp_0='\e[0;38;2;127;191;255m' # lightest

blu_gradient=(
    '\e[0;38;2;127;191;255m'
    '\e[0;38;2;127;127;255m'
    '\e[0;38;2;127;063;255m'
    '\e[0;38;2;127;000;255m'
    '\e[0;38;2;127;000;255m'
    '\e[0;38;2;127;063;255m'
    '\e[0;38;2;127;127;255m'
    '\e[0;38;2;127;191;255m'
)

gradient() {
    str="${*}"
    # string=aaaaa ; ${string:0:5} var:index:length - starts at 0 indexing
    array_index=0
    color_index=0
    str_len="${#str}"
    # length to cut string into and change colors
    length="$((str_len / 8))"

    # color index loops in $length so if length=3 than its 0, 3, 6, 9 etc.. until string is ate up
    while [[ ! $color_index -ge $str_len ]]; do
        printf '%b' "${blu_gradient[$array_index]}${str:$color_index:$length}"
        color_index="$((color_index + length))"
        array_index="$((array_index + 1))"
    done
    # needs a newline otherwise it leaves a % sign
    printf "%s\n" ""
}

garbled_load_text() {
    LC_ALL=C 
    clear
    for ((p=0;p<50;p++)); do
        tput cup 10 10
        tput el
        string=$(tr -dc 'A-Za-z0-9!"#$%&'\''()*+,-./:;<=>?@[\]^_`{|}~' </dev/urandom | head -c 15 ; echo)
        # printf "%s%s%s" "${fg_blu_1}${string:5}${NC}" "${fg_blu_2}${string:6:10}${NC}" "${fg_blu_3}${string:11:15}${NC}"
        echo -e "${fg_blu_1}${string:0:5}${NC}""${fg_blu_2}${string:5:5}${NC}""${fg_blu_3}${string:10:5}${NC}"
        sleep .03
    done
    tput el
    clear_screen
    gradient "Press J or K"
}

bash_finder() {
    # no fd or find use slow ass recursive iteration
    bash_dir="${1}"
    shopt -s globstar
    for wfile in "${bash_dir}"/**/*{.png,.gif,.webp,.jpg}; do 
        printf "%s\n" "$wfile"
    done
    shopt -u globstar
}

bar() {
    mapfile -d '' array < <(fd . "$dir" -0 -tf -e png -e jpg -e gif -e svg -e jpeg)
}

assign () { local var=$1; shift; "$@" > /tmp/myfifo; read -r "${var?}" < /tmp/myfifo; }

show_image() {
    image="${array[$i]}"
    image="${image// /\ }"
    tput cup 10 10
    tput el
    # printf "%s\n" "${array[$i]}"
    # gradient "${array[$i]}"
    gradient "${image}"
}

# remove spaces and escape them. consider printf %q
clean_image() {
    image="${array[$i]}"
    image="${image// /\ }"
}

# ╭───────────────────────────────╮
# │     Arguments && Defaults     │
# ╰───────────────────────────────╯
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help) print_help && exit 0 ;;
        -f|--find) ;;
        -e|--ext) shift && extension="$1";;
        -s|--stdin)  ;;
        -p|--preview) shift && img_preview="$1";;
        *)  [ -d "$1" ] && dir="$1" ;;
    esac
    shift
done
echo "$img_preview"
echo "$extension"
echo "$dir"

# save term state & hide cursor + opts
save_terminal_state
prepare_terminal_state

# handle cleanup on exit so term doesn't get borked
trap redraw WINCH
trap cleanup EXIT INT SIGINT

# what find command to use
if dependency_check fdf; then 
    findcmd="fd"
elif dependency_check fffind; then
    findcmd="find"
else
    findcmd="bash"
fi

# need a more comprehensive terminal check for img protocol
case "$TERM" in
    *kitty*) img_proto="kitty" ;;
    *) img_proto="chafa" ;;
esac

# ╭───────────────────────────────╮
# │      Intitialize Program      │
# ╰───────────────────────────────╯

# dir="${1:-/home/sweet/Pictures}"
dir="${dir:-$HOME/Pictures}"
mapfile -d '' array < <(fd . "$dir" -0 -tf -e png -e jpg -e gif -e svg -e jpeg)
garbled_load_text

while true; do
    # if menu is set to on show it
    if [ "$show_menu" = 1 ]; then
        echo on
    fi

    read -r -s -n 1 key < /dev/stdin 2> /dev/null

    case "$key" in
        j) i=$((i-1)) ; clean_image ; show_image ;;
        k) i=$((i+1)) ; clean_image ; show_image ;;
        J) i=$((i-5)) ; clean_image ; show_image ;;
        K) i=$((i+5)) ; clean_image ; show_image  ;;
        h) lx=$((lx-5)) ; clean_image ; show_image ;;
        l) lx=$((lx+5)) ; clean_image ; show_image ;;
        m) size=$((size+5)) ; clean_image ; show_image ;;
        n) size=$((size-5)) ; clean_image ; show_image ;;
        f) clean_image ; feh --no-fehbg --bg-fill "$image" ;;
        F) clean_image ; feh --bg-fill "$image" ;;
        o) clean_image ; nsxiv "$image" ;;
        c) tput clear && show_image ;;
        x) clean_image && cb copy "$image" ;;
        '') printf "%s\n" "${image}" > /dev/stdout && exit 0;;
        q) exit 0 ;;
    esac

done
   
